In the past, Symfony projects were created with Composer1
, the dependency manager for PHP
applications. However, the current recommendation is to use the Symfony Installer, which has to be
installed before creating your first project.

This file and directory hierarchy is the convention proposed by Symfony to structure your applications.
The recommended purpose of each directory is the following:
• app/config/, stores all the configuration defined for any environment;
• app/Resources/, stores all the templates and the translation files for the application;
• src/AppBundle/, stores the Symfony specific code (controllers and routes), your domain code (e.g.
Doctrine classes) and all your business logic;
• var/cache/, stores all the cache files generated by the application;
• var/logs/, stores all the log files generated by the application;
• var/sessions/, stores all the session files generated by the application;
• tests/AppBundle/, stores the automatic tests (e.g. Unit tests) of the application.
• vendor/, this is the directory where Composer installs the application's dependencies and you should
never modify any of its contents;
• web/, stores all the front controller files and all the web assets, such as stylesheets, JavaScript files
and images.

a bundle is meant to be something that can be reused as a stand-alone piece of software. If
UserBundle cannot be used "as is" in other Symfony apps, then it shouldn't be its own bundle. Moreover,
if InvoiceBundle depends on ProductBundle, then there's no advantage to having two separate bundles.
Create only one bundle called AppBundle for your application logic.
Implementing a single AppBundle bundle in your projects will make your code more concise and easier
to understand.

There is no need to prefix the AppBundle with your own vendor (e.g. AcmeAppBundle), because
this application bundle is never going to be shared.

Another reason to create a new bundle is when you're overriding something in a vendor's bundle
(e.g. a controller). See How to Use Bundle Inheritance to Override Parts of a Bundle.

Chapter 3 : Configuration

Configuration usually involves different application parts (such as infrastructure and security credentials)
and different environments (development, production). That's why Symfony recommends that you split
the application configuration into three parts.

Part 1 : Infrastructure-Related Configuration
Define the infrastructure-related configuration options in the app/config/parameters.yml file.
The default parameters.yml file follows this recommendation and defines the options related to the
database and mail server infrastructure:

Canonical Parameters : NUUU

Part 2 : Application-Related Configuration
Define the application behavior related configuration options in the app/config/config.yml file.
*global parameters must be defined here.

The configuration options defined in the config.yml file usually vary from one environment to another.
That's why Symfony already includes app/config/config_dev.yml and app/config/
config_prod.yml files so that you can override specific values for each environment.

// src/AppBundle/Entity/Post.php
namespace AppBundle\Entity;
class Post
{
const NUM_ITEMS = 10;
The main advantage of defining constants is that you can use their values everywhere in your application.
When using parameters, they are only available from places with access to the Symfony container.
Constants can be used for example in your Twig templates thanks to the constant() function2 :
	<p>
		Displaying the {{ constant('NUM_ITEMS', post) }} most recent results.
	</p>
And Doctrine entities and repositories can now easily access these values, whereas they cannot access the
container parameters:
	namespace AppBundle\Repository;
	use Doctrine\ORM\EntityRepository;
	use AppBundle\Entity\Post;
	class PostRepository extends EntityRepository
	{
		public function findLatest($limit = Post::NUM_ITEMS)
		{
		// ...
		}
	}

Semantic Configuration: Don't Do It
Don't define a semantic dependency injection configuration for your bundles.

As explained in How to Load Service Configuration inside a Bundle article, Symfony bundles have two
choices on how to handle configuration: normal service configuration through the services.yml file
and semantic configuration through a special *Extension class.
Although semantic configuration is much more powerful and provides nice features such as configuration
validation, the amount of work needed to define that configuration isn't worth it for bundles that aren't
meant to be shared as third-party bundles.
Moving Sensitive Options Outside of Symfony Entirely
When dealing with sensitive options, like database credentials, we also recommend that you store them
outside the Symfony project and make them available through environment variables:

# app/config/config.yml
	doctrine:
		dbal:
			password: "%env(DB_PASSWORD)%"

New in version 3.2: Support for runtime environment variables via the %env(...)% syntax was added in
Symfony 3.2. Prior to version 3.2, you needed to use the special SYMFONY__ variables

Chapter 4 : Organizing Your Business Logic

In Symfony applications, business logic is all the custom code you write for your app that's not specific to the framework (e.g. routing and controllers). Domain classes, Doctrine entities and regular PHP classes
that are used as services are good examples of business logic

For most projects, you should store everything inside the AppBundle. Inside here, you can create
whatever directories you want to organize things:
